package wacc

import TypedAST.{
  Add as TypedAdd,
  And as TypedAnd,
  Call as TypedCall,
  Not as TypedNot,
  Or as TypedOr,
  Sub as TypedSub,
  *
}
import wacc.RenamedAST.KnownType.{ArrayType, BoolType, CharType, IntType, PairType, StringType}
import wacc.RenamedAST.{?, KnownType, SemType}
import wacc.Size.*

import java.rmi.UnexpectedException

type HeapLValue = Fst | Snd | ArrayElem

// Agreement: a translate function will:
// 1. put its result in the next available location at the time of its invocation
// 2. unreserve any locations it reserves

sealed class InstructionContext {
  private val instructionCtx = new ListContext[Instruction]()
  private val stringCtx = new ListContext[(String, Label)]()
  private var stringCounter = 0

  /** Get the next string label
   *
   * @return The next string label
   */
  def getStringLabel: Label =
    stringCounter += 1
    s".string_$stringCounter"

  /** Get the list of instructions generated by the translator
   * 
   * @return The list of instructions generated by the translator
   */
  def getInstructions: List[Instruction] = instructionCtx.get

  /** Get the list of strings generated by the translator
   * 
   * @return The list of strings generated by the translator
   */
  def getStrings: List[(String, Label)] = stringCtx.get

  /** Add an instruction to the list of instructions
   * 
   * @param instruction The instruction to add
   */
  def addInstruction(instruction: Instruction): Unit = instructionCtx.add(instruction)

  /** Add a string to the list of strings
   * 
   * @param string The string to add
   */
  def addString(string: String, label: Label): Unit = stringCtx.add((string, label))
}

class Translator {

  // Constants
  /** The size of a pair in bytes */
  private val PAIR_SIZE = 16

  /** The size of a pointer */
  private val POINTER_SIZE = W64

  /** The size of an integer in bytes */
  private val INT_SIZE = 4

  /** The value of NULL */
  private val NULL = 0

  /** The value of TRUE */
  private val TRUE = 1

  /** The value of FALSE */
  private val FALSE = 0

  /** The label for a user-defined function */
  private val FUNCTION_LABEL = "wacc_func_"

  def translate(program: Program): List[Instruction] = {
    given translateCtx: InstructionContext = new InstructionContext()
    given locationCtx: LocationContext = new LocationContext()
    translateStmt(program.body)
    translateCtx.getInstructions
  }

  /** Convert a semantic type to a size
   *
   * @param t The semantic type to convert
   * @return The size of the semantic type
   */
  private def typeToSize(t: SemType): Size = t match {
    case IntType        => W32
    case BoolType       => W8
    case CharType       => W8
    case StringType     => W64
    case ArrayType(_)   => W64
    case PairType(_, _) => W64
    case _              => throw new UnexpectedException("Unexpected Error: Invalid type")
  }

  /** Generates a function name from an id
   * 
   * @param id The id (integer) to generate the function name
   * @return The function name
   */
  private def getFunctionName(id: Int): String = s"$FUNCTION_LABEL$id"

  /** Translates a statement to a list of instructions
   *
   * @param stmt The statement to translate
   */
  private def translateStmt(
      stmt: Stmt
  )(using instructionCtx: InstructionContext, locationCtx: LocationContext): Unit = stmt match {
    case Skip => instructionCtx.addInstruction(Nop)

    case Decl(v, r) =>
      val dest = locationCtx.getNext(typeToSize(v.getType))
      translateRValue(r)
      locationCtx.addLocation(v, dest)

    case Asgn(l, r) =>
      translateRValue(r)
      val resultLoc = locationCtx.reserveNext(typeToSize(l.getType))

      l match {
        case id: Ident =>
          val dest = locationCtx.getLocation(id)
          locationCtx.movLocLoc(dest, resultLoc)

        case h: HeapLValue =>
          val hDest = getHeapLocation(h)
          locationCtx.regInstrN(
            List(hDest, resultLoc),
            None,
            { (regs, _) => Mov(RegPointer(regs(0))(typeToSize(l.getType)), regs(1)) }
          )
      }

    case Read(l) =>
      locationCtx.setUpCall(List())
      // TODO: clib read
      // val (funName, size) = l.getType match {
      //   case IntType  => ("read_int", typeToSize(IntType))
      //   case CharType => ("read_char", typeToSize(CharType))
      //   case _        => throw new RuntimeException("Unexpected Error: Invalid type for read")
      // }
      // instructionCtx.addInstruction(Call(funName))
      // val dest = getLValue(l)
      // instructionCtx.addInstruction(Mov(RAX(size), dest))
      locationCtx.cleanUpCall()

    case Free(e) =>
      // Check for null
      unary(
        e,
        { l =>
          locationCtx.regInstr(l, NULL, { Compare(_, _) })
          instructionCtx.addInstruction(JmpEqual("free_null_error"))

          // Call free
          locationCtx.setUpCall(List(l))
        }
      )

      // TODO:clib free
      locationCtx.cleanUpCall()

    case Return(e) =>
      unary(e, { l => instructionCtx.addInstruction(Mov(RAX(typeToSize(e.getType)), l)) })
      locationCtx.restoreCalleeRegisters()
      instructionCtx.addInstruction(Ret(None))

    case Exit(e) =>
      val dest = locationCtx.getNext(typeToSize(e.getType))
      translateExpr(e)

      // Call exit
      instructionCtx.addInstruction(Mov(RDI(W8), dest))
    // TODO: clib exit

    case Print(e) =>
      val dest = locationCtx.getNext(typeToSize(e.getType))
      translateExpr(e)

      // Call the print function corresponding to the type of the expression
      locationCtx.setUpCall(List(dest))
      e.getType match
        case _ => ??? // TODO
      locationCtx.cleanUpCall()

    case PrintLn(e) =>
      // Print the expression
      translateStmt(Print(e))

      // Print a newline
      locationCtx.setUpCall(List())
      // TODO: call println
      locationCtx.cleanUpCall()

    case If(cond, s1, s2) =>
      val falseLabel = s"if_false_${cond.hashCode()}"
      val endLabel = s"if_end_${cond.hashCode()}"

      branch(endLabel, falseLabel, cond, s1)
      translateStmt(s2)
      instructionCtx.addInstruction(DefineLabel(endLabel))

    case While(cond, body) =>
      val startLabel = s"while_start_${cond.hashCode()}"
      val endLabel = s"while_end_${cond.hashCode()}"

      instructionCtx.addInstruction(DefineLabel(startLabel))
      branch(startLabel, endLabel, cond, body)

    case Begin(body) => translateStmt(body)

    case Semi(s1, s2) =>
      translateStmt(s1)
      translateStmt(s2)
  }

  /**
   * {{{
   * if not cond
   *   goto falseLabel
   * trueBody
   * goto afterTrueLabel
   * falseLabel:
   * }}}
   *
   * @param afterTrueLabel The label to jump to after the true body
   * @param falseLabel The label to jump to if the condition is false
   * @param cond The condition to check
   * @param trueBody The body to execute if the condition is true
   */
  private def branch(afterTrueLabel: String, falseLabel: String, cond: Expr, trueBody: Stmt)(using
      instructionCtx: InstructionContext,
      locationCtx: LocationContext
  ): Unit =
    val dest = locationCtx.getNext(typeToSize(cond.getType))
    translateExpr(cond)

    instructionCtx.addInstruction(Test(dest, TRUE))
    instructionCtx.addInstruction(JmpZero(falseLabel))
    translateStmt(trueBody)
    instructionCtx.addInstruction(Jmp(afterTrueLabel))
    instructionCtx.addInstruction(DefineLabel(falseLabel))

  /** Translates an RValue to and stores the result in the next available location at the time of invocation.
   *
   * @param value The RValue to translate
   */
  private def translateRValue(value: TypedAST.RValue)(using
      instructionCtx: InstructionContext,
      locationCtx: LocationContext
  ): Unit = value match {
    case ArrayLiter(es, ty) =>
      // Calculate size needed for the array
      val size = (typeToSize(ty).toBytes * es.size) + INT_SIZE

      // Allocate memory for the array
      val tempSizeLocation = locationCtx.reserveNext(W32)
      instructionCtx.addInstruction(tempSizeLocation match {
        case r: Register => Mov(r, size)
        case p: Pointer  => Mov(p, size)
      })
      locationCtx.setUpCall(List(tempSizeLocation))
      locationCtx.unreserveLast()
      // TODO: clib malloc
      val ptrLoc: Location = locationCtx.cleanUpCall()

      // Store the size of the array and array elements
      locationCtx.regInstrN[(Immediate, Size)](
        List(ptrLoc),
        Some((es.size, POINTER_SIZE)),
        { (regs, data) => Mov(RegPointer(regs(0))(data._2), data._1) }
      )
      es.zipWithIndex.foreach { (e, i) =>
        val expLoc = locationCtx.getNext(typeToSize(e.getType))
        translateExpr(e)
        val offset: Immediate = i * typeToSize(e.getType).toBytes
        locationCtx.regInstrN[(Immediate, Size)](
          List(ptrLoc, expLoc),
          Some((offset, typeToSize(e.getType))),
          { (regs, data) =>
            Mov(RegImmPointer(regs(0), data._1)(data._2), regs(1))
          }
        )
      }
    case NewPair(e1, e2, PairType(t1, t2)) =>
      // Allocate memory for the pair
      val tempSizeLocation = locationCtx.reserveNext(W32)
      instructionCtx.addInstruction(tempSizeLocation match {
        case r: Register => Mov(r, PAIR_SIZE)
        case p: Pointer  => Mov(p, PAIR_SIZE)
      })
      locationCtx.setUpCall(List(tempSizeLocation))
      locationCtx.unreserveLast()
      // TODO: clib malloc
      val ptrLoc = locationCtx.cleanUpCall()

      // Store the pair elements
      val resultLoc1 = locationCtx.getNext(W64)
      translateExpr(e1)
      locationCtx.regInstrN[Size](
        List(ptrLoc, resultLoc1),
        Some(typeToSize(t1)),
        { (regs, size) => Mov(RegPointer(regs(0))(size), regs(1)) }
      )

      val resultLoc2 = locationCtx.getNext(W64)
      translateExpr(e2)
      val offsetSnd: Immediate = PAIR_SIZE / 2
      locationCtx.regInstrN[(Immediate, Size)](
        List(ptrLoc, resultLoc2),
        Some((offsetSnd, typeToSize(t2))),
        { (regs, data) => Mov(RegImmPointer(regs(0), data._1)(data._2), regs(1)) }
      )
    case f @ Fst(_, ty) =>
      // Get the current location in the map of the Fst
      val fstLoc = getHeapLocation(f)

      // Move this into the expected result location
      val dest = locationCtx.getNext(typeToSize(ty))

      locationCtx.regInstrN(
        List(dest, fstLoc),
        None,
        { (regs, _) => Mov(regs(0), RegPointer(regs(1))(typeToSize(f.getType))) }
      )

    case s @ Snd(_, ty) =>
      // Get the current location in the map of the Snd
      val fstLoc = getHeapLocation(s)

      // Move this into the expected result location
      val dest = locationCtx.getNext(typeToSize(ty))

      locationCtx.regInstrN(
        List(dest, fstLoc),
        None,
        { (regs, _) => Mov(regs(0), RegPointer(regs(1))(typeToSize(s.getType))) }
      )

    case TypedCall(v, args, ty) =>
      // Translate arguments into temporary locations
      val argLocations: List[Location] = args.map { arg =>
        val dest = locationCtx.reserveNext(typeToSize(arg.getType))
        translateExpr(arg)
        dest
      }
      // Save caller-save registers and set up arguments
      locationCtx.setUpCall(argLocations)
      // Free argument temp locations
      argLocations.foreach { _ =>
        locationCtx.unreserveLast()
      }
      // Call the function
      instructionCtx.addInstruction(Call(getFunctionName(v.id)))
      // Restore caller-save registers
      locationCtx.cleanUpCall()
    case e: Expr => translateExpr(e)
    case _       => throw new UnexpectedException("Unexpected Error: Invalid RValue")
  }

  /** Translates an expression. The result of the expression is stored in the next available location at the time of
   * invocation.
   *
   * @param expr The expression to translate
   */
  private def translateExpr(
      expr: TypedAST.Expr
  )(using instructionCtx: InstructionContext, locationCtx: LocationContext): Unit = expr match {
    case TypedNot(e) => unary(e, { l => instructionCtx.addInstruction(Not(l)) })
    case Negate(e)   => unary(e, { l => instructionCtx.addInstruction(Neg(l)) })

    case Len(e) =>
      val lenDest =
        locationCtx.reserveNext(typeToSize(IntType)) // we want to move the size of the array to this location
      unary(e, { l => locationCtx.movLocLoc(lenDest, l) })
      locationCtx.unreserveLast()

    case Ord(e) =>
      val ordDest = locationCtx.reserveNext(typeToSize(IntType))
      unary(e, { l => locationCtx.movLocLoc(ordDest, l) })
      locationCtx.unreserveLast()

    case Chr(e) =>
      val chrDest = locationCtx.reserveNext(typeToSize(CharType))
      unary(e, { l => locationCtx.movLocLoc(chrDest, l) })
      locationCtx.unreserveLast()

    case Mult(e1, e2) =>
      binary(
        e1,
        e2,
        { (regOp1, locOp2) => SignedMul(Some(regOp1), locOp2, None) }
      ) // TODO: runtime error if over/underflow

    case Mod(e1, e2) =>
      val modDest = locationCtx.reserveNext(typeToSize(IntType))
      translateExpr(e2)
      // TODO: runtime error if divide by 0
      val e1Dest = locationCtx.getNext(typeToSize(IntType))
      translateExpr(e1)
      locationCtx.withFreeRegisters(
        List(RAX(typeToSize(IntType)), RDI(typeToSize(IntType))), {
          instructionCtx.addInstruction(Mov(RAX(typeToSize(IntType)), e1Dest))
          instructionCtx.addInstruction(SignedDiv(modDest))
          locationCtx.movLocLoc(modDest, RDI(typeToSize(IntType)))
        }
      )
      locationCtx.unreserveLast()

    case Div(e1, e2) =>
      val divDest = locationCtx.reserveNext(typeToSize(IntType))
      translateExpr(e2)
      // TODO: runtime error if divide by 0
      val e1Dest = locationCtx.getNext(typeToSize(IntType))
      translateExpr(e1)
      locationCtx.withFreeRegisters(
        List(RAX(typeToSize(IntType)), RDI(typeToSize(IntType))), {
          instructionCtx.addInstruction(Mov(RAX(typeToSize(IntType)), e1Dest))
          instructionCtx.addInstruction(SignedDiv(divDest))
          locationCtx.movLocLoc(divDest, RAX(typeToSize(IntType)))
        }
      )
      locationCtx.unreserveLast()

    case TypedAdd(e1, e2) => binary(e1, e2, Add.apply) // TODO: runtime error if over/underflow

    case TypedSub(e1, e2) => binary(e1, e2, Sub.apply) // TODO: runtime error if over/underflow

    case Greater(e1, e2) => cmpExp(e1, e2, SetGreater.apply)

    case GreaterEq(e1, e2) => cmpExp(e1, e2, SetGreaterEqual.apply)

    case Smaller(e1, e2) => cmpExp(e1, e2, SetSmaller.apply)

    case SmallerEq(e1, e2) => cmpExp(e1, e2, SetSmallerEqual.apply)

    case Equals(e1, e2) => cmpExp(e1, e2, SetEqual.apply)

    case NotEquals(e1, e2) =>
      val dest = locationCtx.getNext(typeToSize(BoolType))
      translateExpr(Equals(e1, e2))
      instructionCtx.addInstruction(Not(dest))

    case TypedAnd(e1, e2) => binary(e1, e2, And.apply)

    case TypedOr(e1, e2) => binary(e1, e2, Or.apply)

    case IntLiter(x) =>
      val dest = locationCtx.getNext(typeToSize(IntType))
      instructionCtx.addInstruction(dest match {
        case r: Register => Mov(r, x)
        case p: Pointer  => Mov(p, x)
      })

    case BoolLiter(b) =>
      val dest = locationCtx.getNext(typeToSize(BoolType))
      val bVal = if b then TRUE else FALSE
      instructionCtx.addInstruction(dest match {
        case r: Register => Mov(r, bVal)
        case p: Pointer  => Mov(p, bVal)
      })

    case CharLiter(c) =>
      val dest = locationCtx.getNext(typeToSize(CharType))
      instructionCtx.addInstruction(dest match {
        case r: Register => Mov(r, c)
        case p: Pointer  => Mov(p, c)
      })

    case StringLiter(s) =>
      val label = instructionCtx.getStringLabel
      instructionCtx.addString(s, label)
      val dest = locationCtx.getNext(typeToSize(StringType))

      // Load the address of the string into the destination
      val stringPointer: Pointer = RegImmPointer(RIP, label)(typeToSize(StringType))
      locationCtx.regInstr(dest, stringPointer, { (regOp1: Register, locOp2: Pointer) => Lea(regOp1, locOp2) })

    case PairLiter =>
      val dest = locationCtx.getNext(typeToSize(PairType(?, ?)))
      instructionCtx.addInstruction(dest match {
        case r: Register => Mov(r, NULL)
        case p: Pointer  => Mov(p, NULL)
      })

    case id: Ident =>
      val dest = locationCtx.getNext(typeToSize(id.getType))
      val loc = locationCtx.getLocation(id)
      locationCtx.movLocLoc(dest, loc)

    case elem: ArrayElem =>
      val loc = getHeapLocation(elem)
      val dest = locationCtx.getNext(typeToSize(elem.getType))

      locationCtx.regInstrN(
        List(dest, loc),
        None,
        { (regs, _) => Mov(regs(0), RegPointer(regs(1))(typeToSize(elem.getType))) }
      )

    case NestedExpr(e, ty) => translateExpr(e)
  }

  /** Translates a function.
    *
    * @param f The function to translate
    */
  private def translateFunction(
      f: Func
  )(using instructionCtx: InstructionContext, locationCtx: LocationContext): Unit =
    // Define the function label
    instructionCtx.addInstruction(DefineLabel(getFunctionName(f.v.id)))

    // Set up stack frame and save callee-save registers
    locationCtx.setUpFunc(f.params)

    // Translate the function body
    translateStmt(f.body)

    // Restore callee-save registers and clean up stack frame
    locationCtx.cleanUpFunc()

  /** Compare two expressions and set the result of the comparison in the next available location at the time of
   * invocation.
   *
   * @param e1 The first expression to compare
   * @param e2 The second expression to compare
   * @param setter The function to set the result of the comparison (e.g. SetGreater, SetEqual, etc.)
   */
  private def cmpExp(e1: Expr, e2: Expr, setter: Location => Instruction)(using
      instructionCtx: InstructionContext,
      locationCtx: LocationContext
  ): Unit =
    val dest = locationCtx.getNext(typeToSize(e1.getType))
    translateExpr(e1)
    val e2Dest = locationCtx.getNext(typeToSize(e2.getType))
    translateExpr(e2)
    locationCtx.regInstr(dest, e2Dest, { (regOp1, locOp2) => Compare(regOp1, locOp2) })
    instructionCtx.addInstruction(setter(dest))
    locationCtx.unreserveLast()

  /** Get the location of an LValue that is stored on the heap
   *
   * @param l The LValue to get the location of
   * @return The location of the pointer to the LValue
   */
  private def getHeapLocation(l: HeapLValue)(using
      instructionCtx: InstructionContext,
      locationCtx: LocationContext
  ): Location = l match {

    case elem @ ArrayElem(v, es, ty) =>
      // move the base address of the array to the next available location
      // reserve the base address of the array
      val baseDest = locationCtx.reserveNext(typeToSize(v.getType))
      val baseLoc = locationCtx.getLocation(v)
      locationCtx.movLocLoc(baseDest, baseLoc)

      // Calculate the final location
      es.foldLeft(v.getType) { (tyAcc, e) =>
        tyAcc match {
          case ArrayType(nextTy) =>
            // evaluate the index
            translateExpr(e)
            val indexDest = locationCtx.getNext(typeToSize(e.getType))

            // TODO: runtime error if index out of bounds

            // get the size of the type (for scaling)
            val tySize = typeToSize(nextTy).toBytes

            locationCtx.regInstrN[Unit](
              List(baseDest, indexDest),
              None,
              { (regs, _) =>
                // baseDest = baseDest + indexDest * tySize + 4
                Lea(regs(0), RegScaleRegImmPointer(regs(0), tySize, regs(1), 4)(typeToSize(nextTy)))
              }
            )
            nextTy
          case _ => throw new RuntimeException("Invalid type")
        }
      }

      locationCtx.unreserveLast()

      // Return the final location
      baseDest

    case Fst(l, ty) =>
      // Get the location of the pointer to the pair
      val pairPtrLoc = l match {
        case id: Ident     => locationCtx.getLocation(id)
        case h: HeapLValue => getHeapLocation(h)
      }
      // TODO: runtime error if null

      pairPtrLoc

    case snd @ Snd(l, ty) =>
      // Get the location of the pointer to the pair
      val pairPtrLoc = l match {
        case id: Ident     => locationCtx.getLocation(id)
        case h: HeapLValue => getHeapLocation(h)
      }
      // TODO: runtime error if null

      // Calculate the location of the second element
      val sndDest = locationCtx.getNext(typeToSize(PairType(?, ty)))
      locationCtx.movLocLoc(sndDest, pairPtrLoc)

      // add the offset to the pointer
      val offset = PAIR_SIZE / 2
      locationCtx.regInstr(
        sndDest,
        None,
        { (reg, _) => Lea(reg, RegImmPointer(reg, offset)(typeToSize(ty))) }
      )

      sndDest
  }

  /** Translate a unary operation and store the result in the next available location at the time of invocation.
   *
   * @param e The expression to translate
   * @param instr The instruction to perform on the expression
   */
  private def unary(e: Expr, instr: Location => Unit)(using
      instructionCtx: InstructionContext,
      locationCtx: LocationContext
  ): Unit =
    val dest = locationCtx.getNext(typeToSize(e.getType))
    translateExpr(e)
    instr(dest)

  /**
    * Translate a binary operation and store the result in the next available location at the time of invocation.
    *
    * @param e1 The first expression to translate
    * @param e2 The second expression to translate
    * @param instr The instruction to perform on the two expressions
    * @param check1 Overflow check for the first expression
    * @param check2 Overflow check for both expressions
    */
  private def binary(
      e1: Expr,
      e2: Expr,
      instr: (Register, Location) => Instruction,
      check1: Option[Location => Unit] = None,
      check2: Option[(Location, Location) => Unit] = None
  )(using
      instructionCtx: InstructionContext,
      locationCtx: LocationContext
  ): Unit = {
    val dest = locationCtx.reserveNext(typeToSize(e1.getType))
    translateExpr(e1)
    if check1.isDefined then check1.get(dest)
    val e2Dest = locationCtx.getNext(typeToSize(e2.getType))
    if check2.isDefined then check2.get(dest, e2Dest)
    translateExpr(e2)
    locationCtx.regInstr(dest, e2Dest, { (regOp1, locOp2) => instr(regOp1, locOp2) })
    locationCtx.unreserveLast()
  }
}
